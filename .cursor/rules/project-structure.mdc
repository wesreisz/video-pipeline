---
description: Video Pipeline Project Structure
globs: *
alwaysApply: true
---
# Video Pipeline Project Structure

This project is organized as follows:

## Import Conventions

### Module-Level Imports
When importing within a module (e.g., embedding-module, chunking-module), follow these rules:

1. **Never use relative imports** (avoid `..` or `.`):
   ```python
   # ❌ DON'T use relative imports
   from ..utils.logger import setup_logger
   from .handlers import some_handler
   
   # ✅ DO use absolute imports from module root
   from utils.logger import setup_logger
   from handlers import some_handler
   ```

2. **Never include `src` in import paths**:
   ```python
   # ❌ DON'T include src in paths
   from src.services.openai_service import OpenAIService
   
   # ✅ DO use direct imports from module root
   from services.openai_service import OpenAIService
   ```

3. **Module root is automatically added to PYTHONPATH**:
   - Each module's `src` directory is added to PYTHONPATH in `conftest.py`
   - This allows imports to work from the module root without relative paths
   - Example `conftest.py` setup:
     ```python
     import os
     import sys
     import pytest

     # Add the src directory to the Python path
     sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../src')))
     ```

## Root Directory Structure

- `infra/`: Infrastructure as code
  - `modules/`: Reusable infrastructure modules
  - `environments/`: Environment-specific configurations

- `modules/`: Individual service implementations
  - `chunking-module/`: Service for chunking the transcriptions
  - `transcribe-module/`: Service for transcribing media files
  - `embedding-module/`: Service for creating embeddings and storing them in pinecone

- `samples/`: Sample media files for testing
  - Contains sample audio files (e.g., sample.mp3)

- Configuration files:
  - `pip-requirements.txt`: Python dependencies
  - `dev-requirements.txt`: Development-specific Python dependencies
  - `.gitignore`: Git ignore patterns

This structure follows a modular design pattern where:
1. Services live in `modules/`
2. Infrastructure is defined in `infra/`
3. Sample data for testing is in `samples/`

Each modules should be structured:
- <name>-module
  - specs - llm prompts
  - src - source code
    - handlers
    - models
    - services
    - utils
  - tests
